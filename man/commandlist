N: PIGLET
U: pig
D: execute the piglet graphical editor under X11
T: {
Piglet is started by typing "pig" in a terminal window.  Piglet then
creates an associated graphical window under X11.  The editor scans
both the graphic window and the original shell window that you used to
start piglet.  You can either type coordinates, or click them with the
mouse.  The shell window should have a prompt "MAIN>" at which commands
may be typed.  

When entering points with the mouse, the clicks ALWAYS snap to the grid,
giving a powerful way to enter precise coordinates.

All the piglet built-in commands can be abbreviated to just three
letters with one exception.  DISPLAY must be entered as "DISP" or "disp"
to distinguish it from "DIStance". 

Piglet makes use of the mouse scroll wheel if it exists.  Scrolling the
mouse zooms in or out of the current x,y location.  By moving the mouse
location while zooming it is possible to quickly zoom into any portion
of a drawing.  Zooming can be used in the middle of an ADD command.  For
example, one can mouse the starting coordinate of a line, zoom across
the design, and then click the next coordinate.   If you prefer not to
use the scroll wheel, piglet can also zoom by clicking on a point with the
middle button and dragging either right or left to zoom in and out.

When the editor is idle and not processing any command, a 
left mouse click will recenter the display on the selected point. 

All commands which modify the drawing geometry can be undone with
the UNDO command.  The UNDO depth is limited only by available memory.
Any undone operations can be redone with the REDO command. 
Once the user is satisfied with the state of the drawing, and proceeds 
to modify the geometry further, the REDO buffer is cleared.

Anything typed at the command line goes into a readline buffer.  
A vi command history binding can be obtained by adding the lines

.ti +4
\fBset editing-mode vi\fR
.ti +4
\fBset keymap vi\fR

to the file "~/.inputrc".  See the GNU readline(1) man page for more
details about commandline editing.

.SS FILES

Piglet requires several configuration files to start up.  They are
the TEXT and NOTE font definition files, the MENU definition file and
the PROCESS layer definition file.

Piglet sequentially searches the following directories to find these files.

.nf
    1) current working directory
    2) directory ".pigrc" under the current working directory
    3) directory ".pigrc" in the users HOME directory
    4) /usr/local/lib/piglet
    5) /usr/lib/piglet
.fi


The TEXT and FONT files are named "TEXTDATA.F" and "NOTEDATA.F"
respectively.  The format for both files is plain ASCII.  The file
starts with two integers separated by a comma.  The first gives the
height of each character definition and the second, the width.  Each
character is then listed in printed form and the glyph is defined by a
set of vector coordinates.  It is assumed that each successive x,y
coordinate pair is connected by a stroke unless the path is broken by
the special coordinate "-64,0".  Each definition is terminated by the
special coordinate "-64,-64".  Here is an example of the first three
definitions in "NOTEDATA.F" for the characters <exclam>, <double-quote>,
and <pound>:

.nf
16,12
! 6,2 6,3 -64,0 6,5 6,14 -64,-64
" 4,14 4,10 -64,0 8,14 8,10 -64,-64
# 2,6 10,6 -64,0 2,10 10,10 -64,0 4,2 4,14 -64,0 8,2 8,14 -64,-64
...
.fi

Piglet's menu is also defined by a customizable file "MENUDATA_V".  The default
menu is defined as:

.nf
ayyyyy|ADD |R|P|L|N|T|
ayyygg|SHO |C|A|I|+|-|
ayyggg|GRI |#|^|1|2|3|
ayyggg|WIN |;|!|4|5|6|
yyyggg|:F|:V|:Z|7|8|9|
yyyggg|:D|:S|:V|,|0|.|
yyyyyy|:W|:M|:N|:O|:R|
yyaaaw|:X|:Y|X|Y|@|XY|
ww    |      |       |
aaa   |WRA |SMA |GRO |
aaa   |MOV |COP |STR |
ypy   |IDE |POI |LIS |
ygg   |DIST |DISP |  |
ggg   |DUM |PLO |LOC |
ggy   |ARC |RET |INP |
gw    |CHA |         |
rrr   |UND |BYE |DEL |
yyr   |SAV |EDI |EXI |
.fi

The file consists of fields separated by "|" characters.  The first
field consists of some combination of the characters "wrgbapy" which
denote the colors white, red, green, blue, aqua, purple and yellow. 
There should be as many color designators as remaining fields.  The
subsequent fields on each line will be displayed exactly as shown,
rendered in the corresponding color.  The vertical bars are replaced
with white bounding boxes. 

When using the editor, any mouse picks on the menu boxes inject the menu
text directly into the parse stream.  The menu designer should take care
to leave extra spaces after command names so that any combination of
mouse picks results in intelligible commands.  


The layer definition process file is named "PROCDATA.P".  Its format
is also plain ASCII.  It consists of one EQUate command line per layer.
The following PROCDATA.P file defines the characteristics of  9 
layers.

.nf
EQU :C1 :P1 :M0 :B boundary 0
EQU :C2 :P2 :M1 :D layer1 1
EQU :C3 :P3 :M2 :D layer2 2
EQU :C4 :P4 :M3 :D layer3 3
EQU :C5 :P5 :M4 :S layer4 4
EQU :C6 :P6 :M5 :S layer5 5
EQU :C7 :P7 :M6 :I layer6 6
EQU :C1 :P1 :M0 :I layer7 7
EQU :C2 :P2 :M1 :I layer8 8
.fi

The first line, for example, says that layer 0 is named "boundary",
drawn with color 1 (white), plotted with pen 1, and uses line type 0
(solid).  See the EQUate man page for full details. 

.SS DEBUGGING

Since Piglet is under active development, it is distributed to run under
the gdb() debugger.  The script "pig" runs pig.bin under gdb() When
running under gdb() most run-time errors and signals will kill piglet
and print out a backtrace of the stack.  If you would like help fixing a
bug, please send the last few lines of the printout to Rick Walker
<walker AT omnisterra DOT com> along with some description of what
caused the bug. 

When running pig.bin() without the debugger, piglet traps and ignores
most signals, printing a notification to the terminal: "caught 2:
Interrupt.  Use QUIT command to end program".  However, the special
signal SIGQUIT elicits the message: "caught 3: Quit.  do it again and
I'll die!".  Two SIGQUITs in a row will terminate the program.

}

N: ADD_ARC
U: ADD A<layer> [.<cname>] [@<sname>] [:W<width>] [:R<res>] <xy1> <xy2> [<xy3> ...]  <EOC>
D: Add an arc to the current device
S: complete
T: {
Add an arc.  The coords are starting <xy1>, ending point <xy2>
plus a point on the circumference <xy3>.  After the first two
coords are drawn, a "rubber-banded" arc will be drawn until
the final coordinate terminates the command and draws the arc. 
Multiple arcs can be draw with the same command until an EOC is encounterd.

NOTE: Arcs with width are implemented by drawing a line with width
along the path of the arc.  This means that the finished
arc has an effective radius <width>/2.0 larger than drawn. 

.SS OPTIONS
.TP
.I <layer>
layer number for component
.TP
.I <cname>
component name
.TP
.I <sname>
signal name
.TP
.I <width>
line width
.TP
.I <res>
arc resolution angle (in degrees) (default = 2 degrees)
}

N: ADD_CIRCLE
U: ADD C<layer> [.<cname>] [@<sname>] [:W<width>] [:R<resolution>] [:Y<yxratio>] <xy1> <xy2>... EOC
D: Add a circle to the current device
S: complete
T: {
Add a circle.  Center point <xy1> and a point on the circumference <xy2>
must be specfied.  After adding the centerpoint, a "rubber-banded"
circle is shown on the screen, creating a circle with a radius
coincident with the current mouse position.  Entering the second point
terminates the command and draws the circle. 

The circle will be solid unless a non-zero width is specified, in which
case it will be hollow with a wall-thickness of <width>. 

NOTE: Circles with width are implemented by drawing a line with width
along the perimeter of the circle.  This means that the finished
circle has an outside dimension <width> larger than drawn. 

The <yxratio> argument creates an ellipse with a specified ratio between
major and minor axes.  In this case, point <xy1> places the center of the
oval, and point <xy2> places the extreme of the major axis.  Since the major
axis follows the second point, the oval can be placed at any arbitrary
rotation or size.  See "ADD_OVAL" for a method of creating ovals based on
foci and radius. 

The ":R<resolution>" option gives the resolution in degrees.  This is
handy for making regular polygons.  For instance "ADD C7 :R72" will
create a perfect pentagon.  The pentagon rotates during rubberband
drawing such that the second point, <xy2>, is always on one of the
vertices.  "ADD C7 :R90" is a way to add a rotated square.  "ADD C7
:R120" adds an equilateral triangle. 

.SS OPTIONS
.TP
.I <layer>
layer number for component
.TP
.I <cname>
component name
.TP
.I <sname>
signal name
.TP
.I <width>
width of line
.TP
.I <resolution>
angle (in degrees) circle resolution (default = 2 degrees)
.TP
.I <yxratio>
y-to-x major/minor ratio for creating ovals  (default = 1)
.TP
.I <xy1>
center of the circle.
.TP
.I <xy2>
a point on the radius, or on the major axis if <yxratio>!=1
}

N: ADD_INSTANCE
U: ADD [I] <device> [.<cname>] [@<sname>] [:M<mirror>] [:R<rotation> [:X<x>] [:Y<yxratio>] [:Z<slant>] <xy>... EOC
D: Add an instance (sub-cell) to the current device
S: good
T: {
Add a device instance with rotation, scaling, shearing and mirroring. 
<mirror> can take the values "X","Y","XY", "0", or "OFF" for mirroring
about the X axis, Y axis, or both.  <rotation> is the rotation angle in
decimal degrees in the range -180.00 to +180.00 with 0.01 degree
increment.  Multiple devices can be placed with multiple <xy> points. 
EOC (or double click) is required to terminate the command. 

.SS OPTIONS
.TP
.I <cname>
component name
.TP
.I <sname>
signal name
.TP
.I <mirror>
one of "X", "Y", "XY", "0", or "OFF" for mirroring around a specified axis
.TP
.I <rotation>
angle (in degrees) of instance rotation
.TP
.I <x>
scale factor for instance
.TP
.I <yxratio>
y-to-x ratio for creating a "stretched" instance
.TP
.I <slant>
slant angle (degrees) for "shearing" the instance
.TP
.I <xy>
the location of the instance.
}

N: ADD_LINE
D: Add a line to the current device
U: ADD L<layer> [.<cname>] [@<sname>] [:W<width>] <xy1> <xy2> [<xy3> ...]  EOC
S: good
T: {
Add a line.  Lines are added with "ADD L<layer_number>".  Coordinates
are added with the left-mouse button.  Double-clicking on the same point
will terminate the current line while still allowing new lines to be
created.  Right-clicking or typing ";" will terminate both the line and
the command. 

The LOCK command may be used to constrain line placement.  When
extending a line using the mouse, the mouse coordinate is modified such
that the angle of each new segment is snapped to the closest multiple of
the LOCK angle, consistent with the current drawing grid.  In practice,
this produces precise angles for 45 and 90 degrees, but may result in
slight angle errors for other settings, especially on coarse grids. 
A lock angle of 0 turns off all restrictions on line placement. 

.SS OPTIONS
.TP
.I <layer>
layer number for component
.TP
.I <cname>
component name
.TP
.I <sname>
signal name
.TP
.I <width>
width of line (default=0) (FIXME: not currently subject to resolution setting>
}

N: ADD_NOTE
D: Add a note to the current device
U: ADD N<layer> [.<cname>] [@<sname>] [:F<fontsize>][:J<justification>][:M<mirror>] [:R<rotation>] [:Y<yxratio>] [:Z<slant>]  "string" <xy> EOC
S: good
T: {
Add a note.  A note is zero width text.  <Rotation> is in degrees with
counterclockwise rotations being positive.  <Slant> is in the range
-90.00 to +90.00 degrees with 0.01 resolution, and specifies how many
degrees the y-axis of the character is slanted with respect to the
x-axis.  The note is scaled to have adequate clearance when packed into
single-spaced lines which are <fontsize> apart.  The <yxratio> is used
to proportionally stretch or shrink the text to fill less horizontal
space.  (Note: this is a change from HP Piglet which keeps width
constant while changing height.  This redefinition is much more natural
for creating narrow typefaces.  <Fontsize> controls height, and
<xyratio> controls width.). 

To prevent accidentally adding multiple copies of a text string,
multiple mouse clicks on the same coordinate are ignored and the message
"suppressing double click" is printed to the console. 

The default origin for a note is the lower left or southwest (SW)
corner.  This can be changed by the :J option to any of 9 different
locations.  This feature is very helpful for aligning labels to various
sides of a component. 

The "string" may contain embedded newlines.  These can be entered by
simply typing a carriage return while still in quotes.  This can be
handy for entering a multi-line block of information. 

The font is defined in NOTEDATA.F and is easily changed.  New fonts can
be derived from the Hershey font database.  The format is documented in
readfont.c. 

.SS OPTIONS
.TP
.I <layer>
layer number for component
.TP
.I <cname>
component name
.TP
.I <sname>
signal name
.TP
.I <fontsize>
font is scaled to permit single-spaced text at a y-delta of <fontsize>
.TP
.I <justification>
A number or string defining where the origin of the text block is.  The default is 0 which
corresponds to the lower-left, or southwest (SW) corner.  The permissable numeric and text values 
for <justification>, and their resulting location of origin are:
.nf
   numeric  text  location of origin
   -------  ----  ------------------
      0     SW     lower-left
      1     S      lower-center
      2     SE     lower-right  
      3     W      middle-left
      4     C      center
      5     E      middle-right
      6     NW     upper-left
      7     N      upper-center
      8     NE     upper-right
.fi
.TP
.I <mirror>
one of "X", "Y", "XY", "0", or "OFF" for mirroring around a specified axis
.TP
.I <rotation>
angle (in degrees) for note rotation
.TP
.I <yxratio>
y-to-x ratio for creating "stretched" text
.TP
.I <slant>
slant angle (degrees) for creating italic text
.TP
.I "string"
The string to be added as a note component.  Should be in quotes.
.TP
.I <xy>
The location of the note.
}

N: ADD_OVAL
D: Add an oval to the current device (unimplemented)
U: ADD O<layer> [.<cname>] [@<sname>] [:W<width>] [:R<resolution>] <xy1> <xy2> <xy3>... EOC
S: unimplemented (easy)
T: {
Add an oval (or more precisely, an ellipse).  Three points are required. 
The first two are focal points, and the third coordinate is a point on
the circumference.  Like the circle, if no width is given, then the
figure is drawn solid.  With a non-zero width, the oval is drawn with a
wall thickness of specified width, and with a hollow interior.  Another
way to create an ellipse is to use "ADD C :Y<xyratio>", which allows
specification of the ratio between major and minor axes. 
.SS OPTIONS
.TP
.I <layer>
layer number for component
.TP
.I <cname>
component name
.TP
.I <sname>
signal name
.TP
.I <width>
width of line
.TP
.I <resolution>
resolution (in degrees) for oval approximation
}

N: ADD_POLYGON
D: Add a polygon to the current device
U: ADD P<layer> [.<cname>][@<sname>][:W<width>] <xy1> <xy2> <xy3> [<xy4>...] EOC
S: good
T: {
Add a polygon.  If the last vertex is not the same as the
first, then an error message will be given, and the polygon
will be completed for you.  Normally, the polygon is solid,
unless a non-zero width is specified, which results in
a hollow figure with a wall thickness of <width>.
.SS OPTIONS
.TP
.I <layer>
layer number for component
.TP
.I <cname>
component name
.TP
.I <sname>
signal name
.TP
.I <width> 
linewidth of polygon (unimplemented)
}

N: ADD_RECTANGLE
D: Add a rectangle to the current device
U: ADD R<layer> [.<cname>] [@<sname>] [:W<width>] <xy1> <xy2> EOC
S: good
T: {
Add a rectangle.  The rectangle will be solid unless a
non-zero width is specified, in which case it will be hollow
with a wall-thickness of <width>.  

NOTE: Rectangles with width are implemented by drawing a line with width
along the perimeter of the rectangle.  This means that the finished
rectangle has an outside dimension <width> larger than drawn. 

.SS OPTIONS
.TP
.I <layer>
layer number for component
.TP
.I <cname>
component name
.TP
.I <sname>
signal name
.TP
.I <width>
width of line
}

N: ADD_TEXT
D: Add text to the current device
U: ADD T<layer> [.<cname>] [@<sname>] [:M<mirror>] [:R<rotation>] [:Y<yxratio>] [:Z<slant>] [:F<fontsize>] "string" <xy> EOC
S: good
T: {

Add a text annotation to the drawing.  Text is a fillable polygon font
with line width.  <Rotation> is in degrees with counterclockwise
rotations being positive.  <Slant> is in the range -90.00 to +90.00
degrees with 0.01 resolution, and specifies how many degrees the y-axis
of the character is slanted with respect to the x-axis.  The text is
scaled to have adequate clearance when packed into single-spaced lines
which are <fontsize> apart.  The <yxratio> is used to proportionally
stretch or shrink the text to fill less horizontal space.  (Note: this
is a change from HP Piglet which keeps width constant while changing
height.  This redefinition is much more natural for creating narrow
typefaces.  <Fontsize> controls height, and <xyratio> controls width.). 

The "string" may contain embedded newlines.  These can be entered by
simply typing a carriage return while still in quotes.  This can be
handy for entering a multi-line block of information". 

To prevent accidentally adding multiple copies of a text string,
multiple mouse clicks on the same coordinate are ignored and the message
"suppressing double click" is printed to the console. 

The default origin for text is the lower left or southwest (SW) corner. 
This can be changed by the :J option to any of 9 different locations. 
This feature is very helpful for aligning labels to various sides of a
component. 

The font is defined in TEXTDATA.F and is easily
changed.  New fonts can be easily derived from the Hershey
font database.  The format is documented in readfont.c.
.SS OPTIONS
.TP
.I <layer>
layer number for component
.TP
.I <cname>
component name
.TP
.I <sname>
signal name
.TP
.I <fontsize>
font is scaled to permit single-spaced text at a y-delta of <fontsize>
.TP
.I <justification>
A number or string defining where the origin of the text block is.  The default is 0 which
corresponds to the lower-left, or southwest (SW) corner.  The permissable numeric and text values 
for <justification>, and their resulting location of origin are:
.nf
   numeric  text  location of origin
   -------  ----  ------------------
      0     SW     lower-left
      1     S      lower-center
      2     SE     lower-right  
      3     W      middle-left
      4     C      center
      5     E      middle-right
      6     NW     upper-left
      7     N      upper-center
      8     NE     upper-right
.fi
.TP
.I <mirror>
one of "X", "Y", "XY", "0", or "OFF" for mirroring around a specified axis
.TP
.I <rotation>
angle (in degrees) for text rotation
.TP
.I <yxratio>
y-to-x ratio for creating "stretched" text
.TP
.I <slant>
slant angle (degrees) for creating italic text
.TP
.I "string"
The string to be added as a text component.  Should be in quotes.
.TP
.I <xy>
The location of the text.
}

N: ARChive
D: Create archive file of specified device
U: ARC <eoc>
S: good
T: {
Creates an human readable ASCII file containing all the commands
needed to reconstruct the current device and any sub-cells.  
The archive file contains definitions of all the sub-cells 
used in the drawing, thereby preserving the hierarchy.
}

N: AREa
D: Compute and display area of selected component
S: complete
U: ARE [<component>[<layer>]] xysel [xysel ...] <EOC>
T: {
Calculates and displays the area of the selected component.  The area of
a circle is that of an ideal circle, not the polygonal approximation. 
The area of notes, text and instances is the area of the bounding box. 

The area of lines with width is computed by multiplying the total line
length by the line width.  This gives an exact result for lines that do
not cross themselves. 

The area given for rectangles and polygons is exact.  

Both the area of each component and the cumulative area of all selected
components is displayed after each pick. 

.SS OPTIONS
.TP
.I <component>
A designator limiting the command to a given component.
One of E=everything, A=arc, C=circle, I=instances, L=lines,
N=notes, O=oval, P=polygons, R=rectangles, T=text, or a valid 
instance name.  If an instance name is given, only instances of
that name will be selected.  If no <component> is given, then
components of any type may be selected.
.TP
.I <layer>
Layer number, "0" or omitted designates all layers.  Not used
when <component> is an instance name.
.TP
.I <xysel>
A point to select the component to be measured.
}

N: BACkground
D: Specify a background device for the editor
U: BAC [<cellname>]
S: implemented
T: {

This command allows any device to be used as a background.  The origin
of the background device will be in the same location as the origin of
the device currently being edited.  The device specified as the
background device will display with the same parameters as the current
edit device, but none of its components can be selected for edit
operations.  This is a display only option.  One possible use is to
create special grid devices for custom layouts or forms, without the
form being a part of the device. 

If <cellname> is specified, that particular device is displayed in the
background.  If <cellname> is not specified, no background device will
be displayed.

The use of a background device is completely invisible to all editor
functions.  In particular a WINDOW command with the fit option (:F) will
only fit the edited device, not the (possibly larger) background device.

}

N: BYE
D: Terminate the edit session
U: BYE <EOC>
S: complete
T: {
Quit the editing session.
If the user attempts to QUIt or leave the editor with BYE, a list of all
currently modified devices in memory will be printed warning the user
that the devices have not been properly saved.  If a second BYE or QUIT
is typed, the editor will be killed and all unsaved changes will be
permanently lost.   BYE and QUIT are synonyms.
}

N: CHAnge
D: Change characteristics  of  selected components
U: CHA [<component>[<layer>]] {xysel [<comp_options>|"string"|:L<newlayer>]}... <EOC>
S: working
T: {
Changes characteristics of selected components.  Can be optionally
restricted to specified <component> and <layer>.  In any case, only
components which have been made modifiable by the SHOW command can be
changed. 

An <xysel> point selects and highlights the component to be changed.  A summary
of the current non-default component options is printed to the text window.  The user
can then enter any valid option for the selected component type.  The new option
replaces the old value and the device is redisplayed.  Any number of valid options
may be typed until a new <xysel> is given.

If either a NOTE or TEXT is selected, the associated text will be automatically
placed in the commandline history buffer where it can be easily recalled and edited.
See the GNU readline(3) manual page for details on commandline editing.

.SS OPTIONS
.TP
.I <component>
A designator limiting the command to a given component.
One of E=everything, A=arc, C=circle, I=instances, L=lines,
N=notes, O=oval, P=polygons, R=rectangles, T=text, or a valid 
instance name.  If an instance name is given, only instances of
that name will be selected.  If no <component> is given, then
components of any type may be selected.
.TP
.I <layer>
Layer number, "0" or omitted designates all layers.  Not used
when <component> is an instance name.
.TP
.I <xysel>
A point to select the component to be changed.
.TP
.I :L<newlayer>
A new layer number to replace existing layer
.TP
.I <comp_options>
Any option normally allowed for the selected component type.
.TP
.I "\'"'string\'"'"
A new string for NOTE and TEXT components
}

N: COPy
D: Copy  a  component  from  one  location to another
U: COP [<component>[<layer>]] [[:P] <xysel>] | [:R <xy1> <xy2>] xyref xynewref ... <EOC>
S: complete
T: {
Copies a component in the current device.  Can be optionally restricted
to copy only a specified <component> and <layer>.  In any case, only
components which have been made modifiable by the SHOW command can be
copied.  

Components to be copied can be selected either by point or by region. 
The default mode is select by point.  However, if you change to select
by region with :R, you can later change back with :P.  The selection
mode is "sticky" so you can do multiple moves of the same type
without re-entering the option. 

When selecting by point, an <xysel> selects and highlights the component
to be copied.  A bounding box is displayed after the <xyref> reference
point is given.  The box tracks the mouse until the final location of
the reference point is given by <xynewref>.  Multiple copies can be
placed by simply entering more coordinates before terminating the
command. 

The :R options allows selection by region.  A bounding box is selected
with <xy1> and <xy2>.  A rubberband rectangle will be displayed once
<xy1> is entered.  When <xy2> is entered, the box is remembered, but
erased.  When the <xyref> reference point is given, the bounding box is
redisplayed.  The box tracks the mouse until the final location of the
reference point is given by <xynewref>.  All components lying completely
within the bounding box will be selected.

Double clicking on <xyref> will terminate the current copy allowing the
selection and copying of a new component. 

.SS OPTIONS
.TP
.I <component>
A designator limiting the command to a given component.
One of E=everything, A=arc, C=circle, I=instances, L=lines,
N=notes, O=oval, P=polygons, R=rectangles, T=text, or a valid 
instance name.  If an instance name is given, only instances of
that name will be selected.  If no <component> is given, then
components of any type may be selected.
.TP
.I <layer>
Layer number, "0" or omitted designates all layers.  Not used
when <component> is an instance name.
Layer number, "0" or omitted designates all layers.
.TP
.I <xysel>
A point to select the component to be copied.
.TP
.I <xyref>
A reference point on the component.
.TP
.I <xynewref>
The location for the reference point of the new copy.
.TP
.I :P
Copy by Point (default).  Copy the single component closest to <xysel>. 
.TP
.I :R 
Copy by Region.  Identify zero or more components whose bounding boxes
are entirely contained within the rectangular region defined by <xy1> &
<xy2>.   When selecting by region, a rubber-banded rectangle will be drawn 
after the first coordinate to help the user define the region.
}


N: DATe
D: Print the current date and time to the console
S: complete
U: DAT 
T: {
Prints the current date and time to the console in the format:
"Month/Day/Year Hour:Minutes:Seconds" using 24-hour format.
}

N: DEFine
D: Define a macro
S: unimplemented (moderate)

N: DELete
D: Delete a component
S: works
U: DEL [<comp>[<layer>]] [[:P] <xysel>...] [:R <xy1> <xy2>...] <EOC>
T: {
Deletes a component from the current device.  Optionally can be restricted
to only delete a specified <component> and <layer>.  In any case, only
components which have been made modifiable by the SHOW command can be
deleted.  

Components to be deleted can be selected either by point or by region. 
The default mode is select by point.  However, if you change to delete
by region with :R, you can later change back with :P.  The selection
mode is "sticky" so you can do multiple deletes of the same type
without re-entering the option. 

When selecting by point, an <xysel> selects and highlights the component
to be moved.

The :R options allows selection by region.  A bounding box is selected
with <xy1> and <xy2>.  A rubberband rectangle will be displayed once
<xy1> is entered.  When <xy2> is entered, all components within the bounding
box matching the [<comp>[<layer>]] restriction will be deleted.
.SS OPTIONS
.TP
.I <comp>
A designator limiting the command to a given component type.
One of E=everything, A=arc, C=circle, I=instances, L=lines,
N=notes, O=oval, P=polygons, R=rectangles, T=text, or a valid 
instance name.  If an instance name is given, only instances of
that name will be selected.  If no <comp> is given, then
components of any type may be selected.
.TP
.I <layer>
Layer number, "0" or omitted designates all layers.  Not used
when <component> is an instance name.
Layer number, "0" or omitted designates all layers.
.TP
.I <xysel>
A point to select the component to be deleted.
.TP
.I <xy1>
First corner of the bounding box for delete by region.
.TP
.I <xy2>
Second corner of the bounding box for delete by region.
}

N: DISPlay
U: DISP [ON|OFF]
D: Turn X11 Display on/off
S: complete
T: {
Turns the display on or off.  If given no argument, the display state
is toggled.
}

N: DISTance
D: Measure the distance between two points
S: complete
U: DIS {<xy1> <xy2>} ... EOC
T: {

After entering the first point <xy1> a rubber-banded right-angled
triangle is animated on the screen between <xy1> and the current mouse
location.  The coordinates of both points and the delta_x, delta_y,
and total distance is displayed.

After entering the final point <xy2> a summary is printed to the screen of the
form:

.nf
   xy1=(-600,1100) xy2=(2800,3900) dx=3400, dy=2800, dxy=4404.54 theta=39.4725 (deg.)
.fi

giving the location of each coordinate, the delta_x, delta_y,  delta_xy and the
angle of the line xy1:xy2 with respect to horizontal in degrees.

Pairs of points may be entered indefinitely until receipt of a final EOC or
the entry of another command name.
}

N: DUMp
D: Dump the graphics window to a file
S: PPM file only
U: DUM <EOC>
T: {
The DUMP command creates a Portable Pix Map copy of the current graphic
window in the file "./<device_name>.ppm".  You can view/print/convert
this with xv(1), or convert it to gif format with ppmtogif(1) from the
pbmtools package.
}

N: ECHo
D: Echo the argument to screen
S: unimplemented

N: EDIt
D: Edit a new or old device
U: EDI <device> 
S: good (no edit in place yet)
T: {
Edit a new or old device.  If the <device> argument is given, a
nested edit is performed.  The current device is pushed onto a stack
and the newly specified device becomes the currently edited cell.  When
an edit is terminated with an EXIT, the stack is popped and Piglet
returns to editing the previous device.  There is no limit to the number
of edits that can be stacked, except for the the constraint that no
individual cell may appear more than once in the edit stack.

If the newly specified device is already in memory, the user will
be asked:
.nf
    "Cell already in memory, read in a new copy?: (y/n)?"
.fi
If "y" is typed, the memory copy will be discarded and a new
copy read in from disk.  If "n" is typed, the old memory copy
will be used, continuing the edit from where it was last EXIted.

If the device is not already in memory, a search will be made
for a definition of the device on disk.  If found, the disk definition
will be read into memory and used.  If the device is neither in memory
nor on disk, a new empty device will be created with the name <device>. 

If a previously defined version of the device is found, the grid, grid
color, lock angle, level and window settings will all be returned to their
last settings.  This information is persistent, and is stored on disk in
the ".d" file whenever a device is SAVed. 

Piglet keeps track of the modification state of every device in memory. 
If a user attempts to EXIt a modified device, the EXIt is aborted and a
warning is printed suggesting that the device should be saved before
exiting.  Typing EXIt twice in a row will force an exit leaving the
device in memory, but with the modification bit still set.  The user may
return to editing the device at any time.  If the user attempts to leave
the editor with QUIT or BYE, a list of all currently modified devices in
memory will be printed warning the user that the devices have not been
properly saved.  If a second QUIT or BYE is typed, the editor will be
killed and all unsaved changes will be permanently lost.  

}

N: EQUate
D: Assign pen/line type to a mask layer
U: EQU [:C<color>] [:P<pen>] [:M{S|D|B|[0-6]}] [:F<fill>] [:B|:D|:S|:I] [<label>] <layer>
S: complete
T: {

Associate a mask layer with a color, fill pattern, plotting pen, and a mnemonic
description of its use.  All layers are initally set to detail, solid
green, unfilled, and not plotted. 

The EQU command allows these settings to be customized for a particular
application or IC process.   Normally, EQUate commands are stored in the
file PROCDATA.P and are read in automatically by Piglet on startup.

EQUate commands may only be entered, LISted, and SAVed in the PROCESS subsystem.

.SS EXAMPLE

Here are a few lines from a typical PROCDATA.P file:


.nf
EQU :C7 :P7 :M0 :D :F0 boundary  0
EQU :C1 :P1 :M0 :D :F0 layer1  1
EQU :C2 :P2 :M1 :D :F0 layer2  2
EQU :C3 :P3 :M1 :D :F0 layer3  3
EQU :C4 :P4 :M2 :D :F1 layer4  4
EQU :C5 :P5 :M2 :D :F1 layer5  5
EQU :C6 :P6 :M3 :D :F2 layer6  6
EQU :C7 :P7 :M3 :D :F2 layer7  7
EQU :C8 :P1 :M4 :D :F2 layer8  8
EQU :C9 :P2 :M4 :D :F2 layer9  9
.fi

The first line, for example, says that layer 0 is named "boundary",
drawn with color 7 (white), plotted with pen 7, filled with pattern 0 (unfilled)
and uses line type 0 (solid). 

.SS OPTIONS
.TP
.I <color>
an integer from 1-7 or one of the characters "WRGBCMY" signifying 
white, red, green, blue, cyan, magenta or yellow
.TP
.I <pen>
an integer from 1-7 to specify a plot pen, or 0 to suppress plotting.
Piglet parses this option, and stores it, but pen-based plotting is not
currently implemented.
.TP
.I :M{S|D|B|[0-6]}
Specify the way in which the mask layer is displayed.  S gives solid
lines, D gives dotted lines, and B gives broken (dashed lines).  Line
types can also be designated by numbers.  0-2 are synonymous with S,D,B. 
3 gives "dot-dash", 4 gives "long-short", 5 gives "large-broken", 6
gives "small-broken". 
.TP
.I <fill>
Specify the fill pattern for polygons, rectangles, circles and lines, arcs with
width.  0 gives an unfilled outline drawing. 1 gives a solid fill.  Since
piglet draws by overwriting on the display, two overlapping solid fill patterns
will cause the lower pattern to be obscured.  Fill patterns 2-7 are stipple
patterns designed to have minimal pixel overlap and will allow overlapped
geometries to be visible.  ":F2" gives a 45 degree rising crosshatch.  ":F3"
gives a 45 degree falling crosshatch.  ":F4" gives a diagonal dot pattern.
":F5" gives a rectilinear grid-like dot pattern.  ":F6" gives a brick-like
set of staggered short horizontal lines.  ":F7" gives random dot stipples.
Each family of stipples consists of a set of 10 different phase shifts
corresponding to each pen color.  This prevents stipples of the same pattern,
but different colors from obscuring each other.
.TP
.I :B|:D|:S|:I
Specify the function of the mask layer. B is Boundary, D is Detail, 
S is Symbolic and I is Interconnect.  Detail is normally used for the
actual geometries that are necessary to construct a given device.  Symbolic
layers are used to replace the details of a device with a more
comprehensible symbol.  If the symbolic layers are superimposed on the more
complex detail layers, the designer can use the :N,:D and :S options of the
WINDOW command to show only the symbolic or detailed form of the device.
A properly constructed symbol can allow a circuit to be displayed as
device geometries, schematics, or block diagrams.  Interconnect layers
are used for circuit wiring.  In a detailed display, lines are shown in
their true width, but in a symbolic display they are shown with zero
width (not yet implemented). 
.TP
.I :0
If the ":O" option is provided, the layer will be plotted filled instead of
outlined.
.TP
.I <label>
The <label> associates a short mnemonic name with the mask which will be printed
when components are IDEntified.
.TP
.I <layer>
An integer from 0 to MAX_LAYER which specifies which layer is being modified.
}

N: EXIt
D: Exit from an EDIT, PROCESS, or SEARCH subsystem
S: complete
U: EXI <EOC>
T: {
EXIT from an EDIT.  Piglet keeps track of the modification state of
every device in memory.  If a user attempts to EXIt from a modified
device which has not been saved, the EXIt is aborted and a warning is
printed suggesting that the device should be saved before exiting. 
Typing EXIt twice in a row will force an exit leaving the device in
memory but with the modification bit still set.  The user may return to
editing the device at any time. 

If the user then attempts to leave the editor with QUIT or BYE, a list
of all modified devices in memory will be printed warning the user that
the devices have not been properly saved.  If a second BYE or QUIT is
typed, the editor will be killed and all unsaved changes will be
permanently lost. 

Piglet allows nested editing of cells.  If a second EDIT command is
given before saving the current device, then the current device is
pushed onto a stack and the newly specified device becomes the currently
edited cell.  When such an edit is terminated with an EXIT, the stack is
popped and Piglet returns to editing the previous device.  There is no
limit to the number of edits that can be stacked, except for the the
constraint that no individual cell may appear more than once in the edit
stack. 

}

N: FILes
D: Purge named files
S: complete
U: $FILES <cellname1> <cellname2> .... <EOC>
T: {
$FILES is the first command in an archive files.  It removes all
listed cells from memory.  The cell names are ordered hierarchically from top 
to bottom such that no deletion leaves dangling references for the remaining cells.
The cells are then redefined in the archive in reverse order, from bottom to top so
that there are no forward references. 
}

N: FSIze
D: Set the default font size for text and notes
S: complete
U: FSI [<fontsize>]
T: {
Set the font size for text and notes.

The default font size is 10.0 when the editor is started, but can be changed
with the FSIze command and will be used for any ADD NOTE or ADD TEXT
command that does explicitly specify a font size with the <:f> option. 

Text and Notes entered with the new default will be saved to disk with
the :F<fontsize> option. 

The current <fontsize> can be printed by running FSize without an argument.

.SS OPTIONS
.TP
.I <fontsize>
Size of font.  The total height of all characters in the font is scaled to be approximately
equal to <fontsize>.  Must be a positive floating point number.

}

N: GRId
D: Set grid spacing or turn grid on/off
U: GRI [ON|OFF] [:C<color>] <delta> <skip> [<xorig> <yorig>]]
U: GRI [ON|OFF] [:C<color>] <xdelta> <ydelta> <xskip> <yskip> <xorig> <yorig>
S: complete
T: {
Modify the grid.  If no arguments, will toggle the visibility of
the grid.  The visibility can be explicitly set with "GRI ON" and "GRI
OFF".  The grid color is set with ":C<color>", where <color> is an
integer from 0-7 signifying the colors "white, red, green, blue, cyan,
magenta, yellow". 

Grid takes either 2,4 or 6 numeric arguments.  With two arguments the
grid <delta> and <skip> are set.  "GRI 10 2" forces all mouse picks to
be multiples of 10 units and will display every other grid tick:
0,20,40, etc.  With four arguments the grid can be offset with an origin
of <xorig>,<yorig>.  "GRID 10 1 5 7" displays grid snap points at ...-5,
5,15,25...  in the x direction and ...-3, 7,17,27...  in the y
direction, With 6 arguments the <delta> and <skip> can be set
independently for both x and y axis, creating a non-isotropic grid. 
This can be useful when designing an IC in which metals with different
widths are used for routing signals in x and y directions. 

When entering points with the mouse, the clicks ALWAYS snap to the grid,
giving a powerful way to enter precise coordinates.

.SS OPTIONS
.TP
.I <color>
an integer from 1-7 signifying white, red, green, blue, cyan, magenta or yellow
.TP
.I <delta>
grid spacing for both x,y axes
.TP
.I <skip>
how many snap points to skip for each displayed point
.TP
.I <xorig>
x origin of the grid (default = 0)
.TP
.I <yorig>
y origin of the grid (default = 0)
.TP
.I <xdelta>
grid spacing for x axis
.TP
.I <ydelta>
grid spacing for y axis
.TP
.I <xskip>
grid skip for x axis
.TP
.I <yskip>
grid skip for y axis

.SS DIAGNOSTICS
The grid normally shows intermediate tick marks between major grid
points.  These extra points are suppressed if the spacing goes below 3
pixels per tick.  If the drawing is zoomed further, such that the major
grid ticks would also be displayed with less than 3 pixels per tick, the
entire grid is suppressed, and an error message is printed to the
console.  The grid is still considered to be on even if a "grid
suppressed" message is printed

.SS FILES
The current grid setting and color is saved with the device on disk.
}

N: GROup
D: Create  a  new  device  from  existing components
S: unimplemented

N: HELp
D: Print out quick summary of command
U: HELP [<commandname>] EOC
S: good
T: {
With no arguments prints a list of all commands to the screen.  With <commandname> prints
a short usage summary of the command.  
}

N: IDEntify
D: Identify named instances or components
U: IDE [<comp>[<layer>]][[:P] <xypnt>] | [:R <xy1> <xy2>] ... EOC
S: good
T: {
The IDEntify command highlights and prints out details of selected
components.  Components can be selected either by point or by region. 
The default mode is select by point.  However, if you change to select
by region with :R, you can later change back with :P.  The selection
mode is "sticky" so you can do multiple selections of the same type
without re-entering the option. 
.SS OPTIONS
.TP
.I :R 
Select by Region.  Identify zero or more components whose bounding boxes
are entirely contained within the rectangular region defined by <xy1> &
<xy2>.   When selecting by region, a rubber-banded rectangle will be drawn 
after the first coordinate to help the user define the region.
.TP
.I :P
Select by Point.  Identify the single component closest to <xypnt>. 
.TP
.I <comp>
A designator limiting the command to a given component.
One of E=everything, A=arc, C=circle, I=instances, L=lines,
N=notes, O=oval, P=polygons, R=rectangles, T=text, or a valid 
instance name.  If an instance name is given, only instances of
that name will be selected.  If no <component> is given, then
components of any type may be selected.
.TP
.I <layer>
Layer number, "0" or omitted designates all layers.  Not used
when <component> is an instance name.
}

N: INPut
D: Take command input from a file
S: complete
U: INP <filename> <EOC>
T: {
Looks for a file <filename> in the current directory and reads the commands into Piglet.
}

N: INTerrupt
D: Interrupt  an  ADD  to  issue another command
S: unimplemented

N: LAYer
D: Set the default layer number
U: LAYER [<layer_number>] <EOC>
S: complete
T: {
Change the default layer.
The default layer is zero when the editor is started, but can be changed
with the LAYER command and will be used for any ADD
command that does explicitly specify a layer. 

For example, if the default layer is set to 3 with the command
.ti +4
\fB>LAYER 3;\fR

then performing 
.ti +4
\fB>ADD C 0,0 0,10;\fR

will add a circle on layer 3.
}

N: LEVel
D: Set the logical level of the current device
S: complete
U: LEV <logical_level> <EOC>
T: {
Sets the logical level associated with the current device.  This can be used to selectively
display components using the "WIN :L<level>" command.
}

N: LISt
D: List information about the current environment
S: complete
U: LIS <EOC>
T: {
If in the EDIT subsystem, the LISt command prints out information about the
current device.  Lists the components in the current device including
type, bounding box and options associated with each device.  Lists the
grid, lock and level settings.  Lists whether the current device is
modified. 

If in the PROCESS subsystem, the LISt command prints out the current 
Process file EQUates.
}

N: LOCk
D: Set the default lock angle for a given device
S: complete
U: LOCK <angle>
T: {
Set the lock angle, in degrees, for constraining line segments.  The default
angle is 0.0 which turns off all constraints.  Invoking LOCK without any
arguments prints out the current <angle> setting.

When extending a line using the mouse, the mouse coordinate is modified
such that the angle of each new segment is snapped to the closest
multiple of the LOCK angle, consistent with the current drawing grid. 
In practice, this produces precise angles for 45 and 90 degrees, but may
result in slight angle errors for other settings, especially on coarse
grids. 

This command sets a variable stored with the current device.  The lock
angle is stored in the device definition file, so is persistent across
edits. 
.SS OPTIONS
.TP
.I <angle>
The lock angle in degrees between 0 and 90.  If a floating point number is
given, the resolution will be rounded to the nearest 0.01 degrees.
}

N: MACro
D: Enter the MACRO definition subsystem
S: unimplemented (hard)

N: MENu
D: Change or save the current menu
S: partial
T: {
Piglet's menu is defined by a customizable file "./MENUDATA_V".  The default
menu is defined as:

.nf
ayyyyy|ADD |R|P|L|N|T|
ayyygg|SHO |C|A|I|+|-|
ayyggg|GRI |#|^|1|2|3|
ayyggg|WIN |;|!|4|5|6|
yyyggg|:F|:V|:Z|7|8|9|
yyyggg|:D|:S|:V|,|0|.|
yyyyyy|:W|:M|:N|:O|:R|
yyaaaw|:X|:Y|X|Y|@|XY|
ww    |      |       |
aaa   |WRA |SMA |GRO |
aaa   |MOV |COP |STR |
ypy   |IDE |POI |LIS |
ygg   |DIST |DISP |  |
ggg   |DUM |PLO |LOC |
ggy   |ARC |RET |INP |
gw    |CHA |         |
rrr   |UND |BYE |DEL |
yyr   |SAV |EDI |EXI |
.fi

The file consists of fields separated by "|" characters.  The first field consists of
some combination of the characters "wrgbapy" which denote the colors white, red, green,
blue, aqua, purple and yellow.  There should be as many color designators as remaining
fields.  The subsequent fields on each line will be displayed exactly as shown, rendered
in the corresponding color.  The vertical bars are replaced with white bounding boxes.

When using the editor, any mouse picks on the menu boxes inject the menu text directly
into the parse stream.  The menu designer should take care to leave extra spaces after
command names so that any combination of mouse picks results in intellegible commands.
}


N: MOVe
D: Move a component from one location to another
U: MOV [<component>[<layer>]] { [[:P] <xysel>] | [:R <xy1> <xy2>] xyref xynewref } ... <EOC>
S: complete
T: {
MOves a component in the current device.  Can be optionally restricted
to move only a specified <component> and <layer>.  In any case, only
components which have been made modifiable by the SHOW command can be
moved.  

Components to be moved can be selected either by point or by region. 
The default mode is select by point.  However, if you change to select
by region with :R, you can later change back with :P.  The selection
mode is "sticky" so you can do multiple moves of the same type
without re-entering the option. 

When selecting by point, an <xysel> selects and highlights the component
to be moved.  A bounding box is displayed after the <xyref> reference
point is given.  The box tracks the mouse until the final location of
the reference point is given by <xynewref>. 

The :R options allows selection by region.  A bounding box is selected
with <xy1> and <xy2>.  A rubberband rectangle will be displayed once
<xy1> is entered.  When <xy2> is entered, the box is remembered, but
erased.  When the <xyref> reference point is given, the bounding box is
redisplayed.  The box tracks the mouse until the final location of the
reference point is given by <xynewref>. 

.SS OPTIONS
.TP
.I <component>
A designator limiting the command to a given component.
One of E=everything, A=arc, C=circle, I=instances, L=lines,
N=notes, O=oval, P=polygons, R=rectangles, T=text, or a valid 
instance name.  If an instance name is given, only instances of
that name will be selected.  If no <component> is given, then
components of any type may be selected.
.TP
.I <layer>
Layer number, "0" or omitted designates all layers.  Not used
when <component> is an instance name.
.TP
.I <xysel>
A point to select the component to be moved.
.TP
.I <xyref>
A reference point on the component.
.TP
.I <xynewref>
The new location for the reference point after the move.
.TP
.I :P
Move by Point (default).  Move the single component closest to <xysel>. 
.TP
.I :R 
Move by Region.  Identify zero or more components whose bounding boxes
are entirely contained within the rectangular region defined by <xy1> &
<xy2>.   When selecting by region, a rubber-banded rectangle will be drawn 
after the first coordinate to help the user define the region.
}

N: PLOt
D: Make a postscript plot of the current device
S: letter size only
U: PLO <EOC>
T: {
The PLOT command creates a postscript dump of the current device
in the file "./device_name.ps.  The file is suitable for printing
on letter sized paper, and will automatically fit the drawing to
either landscape or portrait depending on the shape of the drawing.
.SS IMPLEMENTATION DETAILS
Currently, the postscript file is not hierarchical and so can be quite
big.  It would be a nice project to define each cell individually and
then instantiate them hierarchically.  The render time would go up, but
the size of the plot file would shrink dramatically. 

The current implementation always plots the entire device fitted to the
paper.  It would be nice to have it draw only the current windowed view
of the device, leaving fit for an option (:F?). 

There should be options (:P<papersize>?) for plotting to standard paper
sizes and to arbitrary <width>x<height> pages.  The c-code for
postscript plotting is set up to allow this, so it is just 
an exercise in option parsing to enable this feature. 

}

N: POInt
D: Display  the  coordinates  of  specified  point  on  the screen
U: POI <xy1>... EOC
S: complete
T: {
The POInt command takes a series of xy points and simply prints their
coordinates to the screen.  No change is made to the database.
You might also notice that Piglet constantly updates a textual
version of your current mouse coordinates in the upper left hand
corner of the graphical window.
}

N: PROcess
D: Enter the PROCESS subsystem
U: PRO EOC
S: implemented
T: {
Entering the process system allows listing of the process file.
Entering PRO, followed by LISt, will list the current set of layer EQUates which define
layer color, pen type, and line types currently in use.
}

N: PURge
D: Purge device definitions from memory and disk
S: complete
U: PUR <cellname>
T: {
Removes the cell definition from memory, and optionally from harddisk. 
If the command is typed during interactive usage, the user is asked
permission for removing the disk file.  If PURGE is encountered during a
RETRIEVE command, both the disk file and the memory copy are deleted
without asking. 
}

N: QUIt
D: Terminate edit session
S: complete
U: QUI <EOC>
T: {
Quit the editing session.
If the user attempts to QUIt or leave the editor with BYE, a list of all
currently modified devices in memory will be printed warning the user
that the devices have not been properly saved.  If a second BYE or QUIT
is typed, the editor will be killed and all unsaved changes will be
permanently lost.   BYE and QUIT are synonyms.
}

N: REDo
D: REDo the last command
U: RED <EOC>
S: complete
T: {
Reapplies any change to the current cell reversed by the UNDo command.

Piglet makes a copy of the entire device definition list before any 
change and pushes it on an undo stack associated with each device.
The depth of the stack is only limited by available memory.

When an UNDo is performed, the state prior to the UNDo is pushed on
the REDo stack.  UNDo and REDo can be performed in any order up
to the limits of the saved information.  

When the user finally makes a change to the cell
with the any of the ADD, CHAnge, COPy, DELete, MOVe, SMAsh, STRetch,
or WRAp commands, the contents of the REDo stack are
cleared.

The information in both the UNDo and REDo stacks is
lost when the editor is exited.

REDo prints the depth of both the UNDO and REDo stacks.
}

N: RETrieve
D: read commands from an ARCHIVE file
S: complete
U: RET <archivefile>
T: {
Looks for a file at "./cells/<archivefile>_I" and reads those commands into the editor.  A properly formed
archive will PURGE all files before redefining them and will have all hierarchical cell definitions
ordered with no forward references.  This is the case for all Piglet-generated archives.

During the retrieve, the display is turned off and all cellnames are echoed to the display as they are read
in.
}

N: SAVe
D: Save the current file or device to disk
S: complete
U: SAVE <newname>
T: {
Saves the current drawing to a file.  Currently files are saved in the
directory "./cells" with the the name and extension of <cellname>.d. 
Later versions of PD Piglet will add a search path to give flexibility
for the directory used.  If <newname> is given, the current cell is
saved (duplicated) to the file "./cells/<newname>.d".  In this case the
current drawing is still marked modified and will cause an error message
if an attempt is made to exit the editor before saving the current
drawing. 

The SAVE file is a human readable transcript of the exact commands that
you typed and moused to create the cell in the first place.  You can
edit this file (carefully) and the textual changes will take effect next
time you start a new piglet and read in the definition.  The
"<cellname>.d" file contains the definition of the cell <cellname>. 
If <cellname> includes other cells, they will only be called by name in
<cellname>.d and will not be defined unless the program can find the
corresponding ".d" files.  In other words, if you mail a friend a ".d"
file, they will be unable to reconstruct your cell if it has any
hierarchy.  If you want a full, self-contained definition of your work,
then you should use the "ARCHIVE" command which defines every cell
used in a given drawing.

If there have been any NONAME instances created with the WRAP command,
they will be automatically smashed when the device is written to disk.
The wrapped instances will still remain in memory, however, so a given
device may be written multiple times without destroying the temporary
hierarchy created with the wrap command.  When the editor is finally 
closed, all NONAME instances will be permanently lost.

Most commands may be terminated by typing either an EOC or the name of
another command.  SAVE is an exception to this rule.  In the event that
the user accidently types the SAVE command more than once, Piglet will
quietly ignore the extra SAVE commands.  This prevents a command like
"SAVE SAVE <a_new_cellname> EXI" from erroneously saving to the current
cell in addition to <a_new_cellname>.d. 

}

N: SEArch
D: Modify the search path
S: unimplemented (moderate)

N: SET
D: Set environment variables
S: unimplemented (easy)

N: SHEll
D: Run a shell command from within the editor
S: unimplemented (easy)

N: SHOw
D: Define which kinds of things to display
U: SHOW {+|-|#}{EACILN0PRT}<layer>
S: complete
T: {
The SHOW command controls what layers are visible and modifiable in the
drawing.  Changes made with the SHOW command only become visible after the
next WINDOW command.

All drawings default to ALL layers visible and ALL layers non-modifiable
when first created or read from disk.  This feature makes it much safer
to browse critical files with Piglet.  No layers are modifiable unless
explicitly unlocked with the SHOW command.  Changes to the SHOW settings
only affect the component currently being edited.  SHOW settings remain
with each component as long as the component is in memory. 

.SS EXAMPLES
.TP
.B SHO #E;
Make ALL layers visible and modifiable
.TP
.B SHO #E -C7;
Set ALL layers visible and modifiable. except circles on layer 7
.TP
.B SHO -E #R3;
Make nothing editable or visible except rectangles on layer 3 
.TP
.B SHO #E7 +E5; 
Display layers 7 and 5, but only layer 7 is modifiable
.SS OPTIONS
.TP
.I {+|-|#}
One of three modifiers. "+" makes the layer visible, "-" turns off visibility and modifiability, "#" makes
the layer both visible and modifiable.
.TP
.I [EACILN0PRT]
.TP
.I <component>
A designator limiting the command to a given component.
One of E=everything, A=arc, C=circle, I=instances, L=lines,
N=notes, O=oval, P=polygons, R=rectangles, T=text, or a valid 
instance name.  If an instance name is given, only instances of
that name will be selected.  If no <component> is given, then
components of any type may be selected.
.TP
.I <layer>
Layer number, "0" or omitted designates all layers.  Not used
when <component> is an instance name.
}

N: SMAsh
D: Replace an instance with its components
U: SMASH [<device_name>] {<coord>} EOC
S: partial
T: {

The SMAsh command will replace a selected instance with copies of the
individual components that define the instance.  The instance closest to
<coord> is selected.  If <device_name> is given, then only instances of
<device_name> can be selected.  The first <coord> simply highlights the
instance.  The SMAsh is only performed after EOC, which can be a
double-click on the same <coord> or a command terminating semi-colon
(;).  Using a double-click allows multiple SMAshes to be performed with
one command. 

Instances to be SMAshed can be scaled, mirrored, or rotated.  Instances
that have been sheared with the :Z option or aspected with the :Y option
may not be smashed.  This could lead to distorted geometries which do
not fit on the grid due to round off errors.  

Rectangles rotated by exact multiples of 90 degrees will remain as
rectangles after SMAshing.  Rectangles rotated by non-orthogonal angles
will be smashed into equivalent polygons. 

Smashing should be done with care.  Smashing a instance destroys the
hierarchy of the drawing and can tremendously increase the number of
components in a device. 

}

N: SPLit
D: Cut a component into two halves
S: unimplemented (moderate)

N: STEp
D: Copy a component in an array fashion
S: unimplemented (moderate)

N: STRetch
D: Move an internal point of a component
S: partial
U: STR [[<component>[<layer>]] {[:P] <xysel> <xyref> <xynewref> } ...
U: STR [[<component>[<layer>]] {:R <xyll> <xyur> <xyref> <xynewref> } ...
T: {

STRetch can move either single vertices or edges of components as selected
by <xysel>, or multiple vertices selected by the bounding box <xyll> <xyur>.
The default mode is to STRetch by point.  To select by region, the ":R" option
can be given.  Once the mode has been switched to region, the :P option can be used
to return to point selection mode.

.SS STRetch by point

STRetch moves either a vertex or an edge of a Rectangle, Line or
Polygon to a new location with respect to a specified reference point. 

STRetch applied to a Circle modifies the point on the circumference of
the circle. 

As a convenience, and because STRetch is commonly used to "tidy up" a
drawing, a STRetch applied to Notes, Text and Instances behaves the same
as the MOVE command. 

The <xysel> point selects the component to be modified.  The <xyref>
point selects the edge or vertex to be modified and acts a reference
point for the move.  Only components matching the optional <component>
and <layer> descriptors will be selected. 

The distance between <xyref> and each of the vertices is tested along
with the distance between <xyref> and the mid-point of each line, polygon or
rectangle segment.  If <xyref> is closer to a vertex, then the delta between
<xyref> and <xynewref> will be added to the vertex.  If <xyref> is
closer to a midpoint, then the delta between <xyref> and <xynewref> will
be added to both the endpoints of the selected segment. 

The placement of <xynewref> is snapped to the nearest grid point such
that the angle between <xyref> and <xynewref> satisfies the current
<lock> angle set by the LOCK command.  This can be used to keep
manhattan geometries precisely orthogonal. 

.SS STRetch by region

When the :R option is given, STRetch will pull all component points
matching the <component> and <layer> descriptors that lie within the
bounding box given by <xyll> and <xyur>.  Any two diagonal corners of
the bounding box may be specified.  After entering <xyll> a
rubber-banded outline will track the mouse to help with the placement of
<xyur>. 

Once the components and nodes have been selected, they are moved by
the vector difference between <xyref> and <xynewref>.  After entering
<xyref> all affected components are drawn in rubber-band mode until 
finally entering <xynewref>.

Components fully enclosed by the bounding box are simply moved.

.SS OPTIONS
.TP
.I <component>
A designator limiting the command to a given component.
One of E=everything, A=arc, C=circle, I=instances, L=lines,
N=notes, O=oval, P=polygons, R=rectangles, T=text, or a valid 
instance name.  If an instance name is given, only instances of
that name will be selected.  If no <component> is given, then
components of any type may be selected.
.TP
.I <layer>
Layer number, "0" or omitted designates all layers.  Not used
when <component> is an instance name.
.TP
.I <xysel>
xy-coordinate to select the component to be modified.
.TP
.I <xyll>
xy-coordinate of one corner of the bounding box used to select multiple vertices
.TP
.I <xyur>
xy-coordinate diagonally opposite <xyll> specifying the bounding box used to select multiple vertices
.TP
.I <xyref>
A reference point on the component which selects which vertex or line segment to modify.
.TP
.I <xynewref>
The location for the reference point of the new copy.
}

N: TRAce
D: Highlight named signals
S: unimplemented (easy)

N: TSLant
D: Get or set the default font slant for italic text and notes
S: complete
U: TSL [<slant>] <EOC>
T: {
Set the default font slant for italic text and notes.

The default font slant is zero when the editor is started, but can be changed
with the TSLant command and will be used for any ADD NOTE or ADD TEXT
command that does explicitly specify a slant with the <:z> option.  

Text or Notes added with a non-zero TSLant will be saved with the :z
option set to <slant>. 

The current <slant> value can be printed by running TSLant without an argument.

.SS OPTIONS
.TP
.I <slant>
Angle to slant text and notes.  Limited to +/- 45.0 degrees.
A positive slant leans to the right, approximating an italic font.
}


N: UNDo
D: Undo the last command
U: UND <EOC>
S: complete
T: {
Reverses the last change to the current cell.  UNDO reverses changes
made with the ADD CHAnge COPy DELete MOVe SMAsh STRetch and WRAp
commands.

Piglet makes a copy of the entire device definition list before any 
change and pushes it on an undo stack associated with each device.
The depth of the stack is only limited by available memory.

When an UNDo is performed, the state prior to the UNDo is pushed on
the REDo stack.  UNDo and REDo can be performed in any order up
to the limits of the saved information.  

When the user finally makes a change to the cell
with the any of the ADD, CHAnge, COPy, DELete, MOVe, SMAsh, STRetch,
or WRAp commands, the contents of the REDo stack are
cleared.

The information in both the UNDo and REDo stacks is
lost when the editor is exited.

UNDO prints the depth of both the UNDO and REDo stacks.
}

N: UNIts
D: Set   editor  resolution  and  user  unit  type
S: unimplemented

N: VERsion
D: Identify the version number of program
S: complete

N: WINdow
D: Change the current window parameters
U: WINdow :X[<scale>] [:N<physical>] [:F] [:Z] [:O] [<xy1> [<xy2>]] <EOC>
S: good
T: {
Window with no arguments simply refreshes the display.  With only <xy1>
the window is re-centered (panned) to the new point.  With both <xy1> and
<xy2> the window is zoomed to the new bounding box.  If EOC is given by
a double click, multiple window commands can be entered in succession. 

The last window setting used in editing a device is saved along with the
device so that the same editing environment can be restored the next
time the device is edited.

If you have a very complex drawing with lots of hierarchy, you can
simplify things by using the ":N<nest_level>" of the WIN command.  "WIN
:N0" will show all sub-cells as bounding boxes.  "WIN :N1" will show all
sub-cells of sub-cells as bounding boxes, and so on.

Piglet defaults to drawing unfilled polygons.  "WIN :O" will toggle filling.

.SS OPTIONS
.TP
.I <scale>
Factor by which to scale the current window.  Limited to range 
of 0.01 ... 100.0.
.TP
.I :F
Specify fitting the window to the bounding box of the current device
.TP
.I :N<physical>
Only display nesting down to <physical> number of hierarchy levels (default=3)
.TP
.I :O 
Toggle filled polygon display  (default=unfilled)
.TP
.I :Z 
Toggles window to previous settings.
}

N: WRAp
D: Create  a  new  device  using  existing components
S: complete
U: WRAP [<component>[<layer>]] [<devicename>] <xyorig> <xy1> <xy2> EOC
T: {
Creates a new device out of the selected components.  Selection is done
by taking all the components completely enclosed by the rectangular
region defined by <xy1> and <xy2>.  Components can be further restricted by
the optional <component><layer> argument. Partially enclosed components are
omitted from the new device definition.  Once selected, the group of
components is replaced by an instance named <devicename> of the newly
created device definition.  The <devicename> is automatically saved to disk
when it is created.  It is an error for <devicename> to exist either in
memory or on disk prior to the WRAp command. 

WRAp is commonly used to MOVe or COPy various sub-regions of a drawing. 
For this purpose, <devicename> can be omitted, and a unique name of the
form "NONAME_<number>" will be automatically generated.  Such components
can be subsequently MOVed or COPied and will be automatically smashed
onto the disc when the current device is saved.  NONAME instances may be
mirrored, scaled, or rotated by CHAnge command, but may not be sheared
(:Z) or aspected (:Y).  If you need to shear or aspect a geometry, you
must encapsulated it in a permanently named instance, which may not be
subsequently smashed. 

The GROUP command is identical to WRAp in function except that
components are selected individually instead of by region. 

.SS OPTIONS
.I <component>
A designator limiting the command to a given component.
One of E=everything, A=arc, C=circle, I=instances, L=lines,
N=notes, O=oval, P=polygons, R=rectangles, T=text. 
If omitted, any component type may be selected.
.TP
.I <layer>
Limit selection to layer number, "0" or omitted designates all layers.
.TP
.I <devicename>
The name to be used for the new wrapped instance.  If omitted, an
internally generated name of the form "NONAME_<number>" will be used.
.TP 
.I <xyorig>
The point which will become the 0,0 coordinate in the new instance.
.TP 
.I <xy1> <xy2>
The bounding box used to select components to be wrapped.
}

#N: CALibrate
#D: Calibrate the display to match a digitizing tablet
#S: unimplemented

#N: CMAp
#D: Modify the color map
#S: unimplemented

#N: DEClare
#D: Declare a stretch point in a cell
#S: unimplemented

N: MEMory
D: Print remaining memory
S: unimplemented

N: TIMe
D: Print the current and elapsed time to the console
S: complete
U: TIM
T: {
Prints the current 24-hour time to the console in the format:
"Hour:Minutes:Seconds".  If TIMe had been called previously,
the elapsed time will also be printed.

For example:
.nf
    MAIN> time
        07/29/2006 19:11:14
    MAIN> time
	07/29/2006 19:11:18, elapsed since last call: 4 seconds
.fi

TIMe can be useful in scripts for benchmarking internal Piglet operations.
}

#N: XASsign
#D: Assign Stretch points to a cell
#S: unimplemented

#N: YASsign
#D: Assign Stretch points to a cell
#S: unimplemented

#N: ZAP
#D: Delete components with zero extent
#S: unimplemented


